type CacheEntry<T> = { value: T; expiresAt: number };
/**
 * Wraps an async function with a simple in-memory cache.
 * The cache key is generated by JSON-stringifying the function arguments.
 * Each cache entry expires after `ttlSeconds`.
 *
 * @param fn - The async function to be wrapped with caching.
 * @param ttlSeconds - Time-to-live for each cache entry in seconds.
 * @returns A new function that caches results of the original function.
 */
export function withCache<TArgs extends any[], TReturn>(
  func: (...args: TArgs) => Promise<TReturn>,
  ttlSeconds: number,
) {
  const store = new Map<string, CacheEntry<TReturn>>();
  return async (...args: TArgs) => {
    const key = JSON.stringify(args);
    const now = Date.now();
    const cached = store.get(key);
    if (cached && cached.expiresAt > now) return cached.value;
    const val = await func(...args);
    store.set(key, { value: val, expiresAt: now + ttlSeconds * 1000 });
    return val;
  };
}
